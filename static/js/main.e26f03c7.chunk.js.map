{"version":3,"sources":["components/TaskItem.tsx","components/TaskList.tsx","components/TaskInput.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["TaskItem","task","handleDone","handleDelete","className","done","type","onClick","defaultChecked","title","TaskList","tasks","setTasks","prev","map","t","id","filter","length","TaskInput","useState","inputTitle","setInputTitle","count","setCount","placeholder","value","onChange","e","target","initialState","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"wNA6BeA,EApBmB,SAAC,GAAwC,IAAtCC,EAAqC,EAArCA,KAAMC,EAA+B,EAA/BA,WAAYC,EAAmB,EAAnBA,aACnD,OACI,qBAAIC,UAAWH,EAAKI,KAAO,OAAS,GAApC,UACI,kCACI,uBACIC,KAAK,WACLF,UAAU,iBACVG,QAAS,kBAAML,EAAWD,IAC1BO,eAAgBP,EAAKI,OAEzB,sBAAMD,UAAU,iBAAhB,SAAmCH,EAAKQ,WAE5C,wBACIF,QAAS,kBAAMJ,EAAaF,IAC5BG,UAAU,gBAFd,8BCwBGM,EApCmB,SAAC,GAAyB,IAAvBC,EAAsB,EAAtBA,MAAOC,EAAe,EAAfA,SAClCV,EAAa,SAACD,GAChBW,GAAS,SAAAC,GAAI,OAAIA,EAAKC,KAAI,SAAAC,GAAC,OACvBA,EAAEC,KAAOf,EAAKe,GAAd,2BACUf,GADV,IACgBI,MAAOJ,EAAKI,OACtBU,SAIRZ,EAAe,SAACF,GAClBW,GAAS,SAAAC,GAAI,OAAIA,EAAKI,QAAO,SAAAF,GAAC,OAC1BA,EAAEC,KAAOf,EAAKe,UAItB,OACI,qBAAKZ,UAAU,QAAf,SAEIO,EAAMO,QAAU,EAAI,+EACpB,oBAAId,UAAU,YAAd,SAEIO,EAAMG,KAAK,SAAAb,GAAI,OACX,cAAC,EAAD,CAEIA,KAAMA,EACNE,aAAcA,EACdD,WAAYA,GAHPD,EAAKe,Y,OCkBnBG,EA1CoB,SAAC,GAAyB,IAAvBP,EAAsB,EAAtBA,SAAUD,EAAY,EAAZA,MAAY,EAClBS,mBAAiB,IADC,mBAChDC,EADgD,KACpCC,EADoC,OAE5BF,mBAAiBT,EAAMO,OAAS,GAFJ,mBAEhDK,EAFgD,KAEzCC,EAFyC,OAGdJ,oBAAkB,GAHJ,6BAyBxD,OACI,8BACI,qBAAKhB,UAAU,YAAf,SACI,sBAAKA,UAAU,QAAf,UACI,uBACIE,KAAK,OACLmB,YAAY,6CACZC,MAAOL,EACPM,SA5BM,SAACC,GACvBN,EAAcM,EAAEC,OAAOH,UA6BX,wBAAQnB,QA1BH,WACE,KAAfc,IAGJG,EAASD,EAAQ,GAQjBX,EAAS,CANa,CAClBI,GAAIO,EACJd,MAAOY,EACPhB,MAAM,IAGF,mBAAcM,KACtBW,EAAc,MAa6BlB,UAAU,iBAAzC,kCCrCd0B,G,MAAuB,CACzB,CACId,GAAI,EACJP,MAAO,uCACPJ,MAAM,GAEV,CACIW,GAAI,EACJP,MAAO,6CACPJ,MAAM,KAoBC0B,EAhBO,WAAO,IAAD,EACEX,mBAASU,GADX,mBACjBnB,EADiB,KACVC,EADU,KAGxB,OACI,gCACI,qBAAKR,UAAU,YAAf,SACI,qBAAKA,UAAU,QAAf,SACI,uBAAOE,KAAK,OAAOF,UAAU,cAGrC,cAAC,EAAD,CAAUQ,SAAUA,EAAUD,MAAOA,IACrC,cAAC,EAAD,CAAWC,SAAUA,EAAUD,MAAOA,QClB9BqB,QACa,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZRC,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,SDqIzC,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.e26f03c7.chunk.js","sourcesContent":["import React from 'react';\nimport { Task } from '../Types'\n\ntype Props = {\n    task: Task\n    handleDone: (task: Task) => void\n    handleDelete: (task: Task) => void\n}\n\nconst TaskItem: React.FC<Props> = ({ task, handleDone, handleDelete }) => {\n    return (\n        <li className={task.done ? 'done' : ''}>\n            <label>\n                <input\n                    type=\"checkbox\"\n                    className=\"checkbox-input\"\n                    onClick={() => handleDone(task)}\n                    defaultChecked={task.done}\n                />\n                <span className=\"checkbox-label\">{ task.title }</span>\n            </label>\n            <button\n                onClick={() => handleDelete(task)}\n                className=\"btn is-delete\"\n            >削除</button>\n        </li>\n    )\n}\n\nexport default TaskItem","import React from 'react';\nimport TaskItem from './TaskItem';\nimport { Task } from '../Types';\n\ntype Props = {\n    tasks: Task[]\n    setTasks: React.Dispatch<React.SetStateAction<Task[]>>\n}\n\nconst TaskList: React.FC<Props> = ({ tasks, setTasks }) => {\n    const handleDone = (task: Task) => {\n        setTasks(prev => prev.map(t => \n            t.id === task.id\n                ? {...task, done: !task.done}\n                : t\n            ))\n    }\n\n    const handleDelete = (task: Task) => {\n        setTasks(prev => prev.filter(t => \n            t.id !== task.id\n            ))\n    }\n\n    return (\n        <div className=\"inner\">\n        {\n            tasks.length <= 0 ? '登録されたTODOはありません。' :\n            <ul className=\"task-list\">\n            {\n                tasks.map( task => (\n                    <TaskItem\n                        key={task.id}\n                        task={task}\n                        handleDelete={handleDelete}\n                        handleDone={handleDone}\n                    />\n                ))\n            }\n            </ul>\n        }\n        </div>\n    )\n}\n\nexport default TaskList","import React, { useState } from 'react';\nimport { Task } from '../Types';\n\ntype Props = {\n    setTasks: React.Dispatch<React.SetStateAction<Task[]>>\n    tasks: Task[]\n}\n\nconst TaskInput: React.FC<Props> = ({ setTasks, tasks }) => {\n    const [ inputTitle, setInputTitle ] = useState<string>('')\n    const [ count, setCount ] = useState<number>(tasks.length + 1)\n    const [ isTitleEmpty, setIsTitleEmpty ] = useState<boolean>(false)\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        setInputTitle(e.target.value)\n    }\n\n    const handleSubmit = () => {\n        if (inputTitle === '') {\n            return\n        }\n        setCount(count + 1)\n\n        const newTask: Task = {\n            id: count,\n            title: inputTitle,\n            done: false\n        }\n\n        setTasks([newTask, ...tasks])\n        setInputTitle('')\n    }\n\n    return (\n        <div>\n            <div className=\"inputForm\">\n                <div className=\"inner\">\n                    <input\n                        type=\"text\"\n                        placeholder=\"コメントを入力\"\n                        value={inputTitle}\n                        onChange={handleInputChange}\n                    />\n                    <button onClick={handleSubmit} className=\"btn is-primary\">追加</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nexport default TaskInput","import React, { useState } from 'react'\nimport TaskList from './components/TaskList'\nimport TaskInput from './components/TaskInput'\nimport { Task } from './Types';\nimport './App.css';\n\nconst initialState: Task[] = [\n    {\n        id: 2,\n        title: '次にやるやつ',\n        done: false\n    },\n    {\n        id: 1,\n        title: '初めにやるやつ',\n        done: true\n    }\n]\n\nconst App: React.FC = () => {\n    const [tasks, setTasks] = useState(initialState)\n\n    return (\n        <div>\n            <div className=\"inputForm\">\n                <div className=\"inner\">\n                    <input type=\"text\" className=\"input\" />\n                </div>\n            </div>\n            <TaskList setTasks={setTasks} tasks={tasks} />\n            <TaskInput setTasks={setTasks} tasks={tasks} />\n        </div>\n    )\n}\n\nexport default App","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.0/8 are considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n  );\n  \n  type Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n  };\n  \n  export function register(config?: Config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n      // The URL constructor is available in all browsers that support SW.\n      const publicUrl = new URL(\n        process.env.PUBLIC_URL,\n        window.location.href\n      );\n      if (publicUrl.origin !== window.location.origin) {\n        // Our service worker won't work if PUBLIC_URL is on a different origin\n        // from what our page is served on. This might happen if a CDN is used to\n        // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n        return;\n      }\n  \n      window.addEventListener('load', () => {\n        const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n  \n        if (isLocalhost) {\n          // This is running on localhost. Let's check if a service worker still exists or not.\n          checkValidServiceWorker(swUrl, config);\n  \n          // Add some additional logging to localhost, pointing developers to the\n          // service worker/PWA documentation.\n          navigator.serviceWorker.ready.then(() => {\n            console.log(\n              'This web app is being served cache-first by a service ' +\n                'worker. To learn more, visit https://bit.ly/CRA-PWA'\n            );\n          });\n        } else {\n          // Is not localhost. Just register service worker\n          registerValidSW(swUrl, config);\n        }\n      });\n    }\n  }\n  \n  function registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n      .register(swUrl)\n      .then(registration => {\n        registration.onupdatefound = () => {\n          const installingWorker = registration.installing;\n          if (installingWorker == null) {\n            return;\n          }\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the updated precached content has been fetched,\n                // but the previous service worker will still serve the older\n                // content until all client tabs are closed.\n                console.log(\n                  'New content is available and will be used when all ' +\n                    'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n                );\n  \n                // Execute callback\n                if (config && config.onUpdate) {\n                  config.onUpdate(registration);\n                }\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // \"Content is cached for offline use.\" message.\n                console.log('Content is cached for offline use.');\n  \n                // Execute callback\n                if (config && config.onSuccess) {\n                  config.onSuccess(registration);\n                }\n              }\n            }\n          };\n        };\n      })\n      .catch(error => {\n        console.error('Error during service worker registration:', error);\n      });\n  }\n  \n  function checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl, {\n      headers: { 'Service-Worker': 'script' }\n    })\n      .then(response => {\n        // Ensure service worker exists, and that we really are getting a JS file.\n        const contentType = response.headers.get('content-type');\n        if (\n          response.status === 404 ||\n          (contentType != null && contentType.indexOf('javascript') === -1)\n        ) {\n          // No service worker found. Probably a different app. Reload the page.\n          navigator.serviceWorker.ready.then(registration => {\n            registration.unregister().then(() => {\n              window.location.reload();\n            });\n          });\n        } else {\n          // Service worker found. Proceed as normal.\n          registerValidSW(swUrl, config);\n        }\n      })\n      .catch(() => {\n        console.log(\n          'No internet connection found. App is running in offline mode.'\n        );\n      });\n  }\n  \n  export function unregister() {\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.ready.then(registration => {\n        registration.unregister();\n      });\n    }\n  }","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}